// istanbul ignore next
'use strict';

var _interopRequireDefault = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

// istanbul ignore next

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };

// istanbul ignore next

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _list = require('postcss/lib/list');

var _list2 = _interopRequireDefault(_list);

var _balanced2 = require('balanced-match');

var _balanced3 = _interopRequireDefault(_balanced2);

exports['default'] = _postcss2['default'].plugin('postcss-quantity-queries', function () {
  return function (css) {
    css.eachRule(processRule);
    css.eachAtRule(processAtRule);
  };
});

var rePseudo = /(.*)(?::{1,2})(at-(?:least|most)|between|exactly)/;
var reAtRule = /(at-(?:least|most)|between|exactly)/;

function processRule(rule) {
  if (!rePseudo.test(rule.selector)) {
    return;
  }rule.selectors = rule.selectors.map(function (s) {
    var _balanced = _balanced3['default']('(', ')', s);

    var pre = _balanced.pre;
    var body = _balanced.body;

    var args = _list2['default'].comma(body);

    var _pre$split = pre.split(/:{1,2}/);

    var _pre$split2 = _slicedToArray(_pre$split, 2);

    var selector = _pre$split2[0];
    var quantifier = _pre$split2[1];

    return quantifiers[quantifier].apply(quantifiers, _toConsumableArray(args))([selector]);
  });
}

function processAtRule(atRule) {
  if (!reAtRule.test(atRule.name)) {
    return;
  }var args = _list2['default'].space(atRule.params);
  var parent = atRule.parent;
  var root = parent.root();
  var selectors = quantifiers[atRule.name].apply(quantifiers, _toConsumableArray(args))(parent.selectors);

  var newRule = _postcss2['default'].rule({
    selectors: selectors,
    nodes: atRule.nodes,
    source: atRule.source,
    semicolon: true });

  cleanIndent(newRule);

  root.insertAfter(parent, newRule);
  atRule.removeSelf();

  if (!parent.nodes.length) parent.removeSelf();
}

var cleanIndent = function cleanIndent(rule) {
  return rule.eachDecl(function (decl) {
    decl.before = decl.before.replace(/[^\S\x0a\x0d]{2,}/, '  ');
  });
};

var quantitySelectors = function quantitySelectors(quantifier, last) {
  return function (selectors) {
    return selectors.map(function (s) {
      return '' + s + '' + quantifier + ', ' + s + '' + quantifier + ' ~ ' + (last || _list2['default'].space(s).pop());
    });
  };
};

var quantifiers = {

  'at-least': function atLeast(count, last) {
    return quantitySelectors(':nth-last-child(n+' + count + ')', last);
  },

  'at-most': function atMost(count, last) {
    return quantitySelectors(':nth-last-child(-n+' + count + '):first-child', last);
  },

  between: function between(start, end, last) {
    return quantitySelectors(':nth-last-child(n+' + start + '):nth-last-child(-n+' + end + '):first-child', last);
  },

  exactly: function exactly(count, last) {
    return quantitySelectors(':nth-last-child(' + count + '):first-child', last);
  } };
module.exports = exports['default'];